#!/usr/bin/python3

bodies = {}
orbits = {}

import math
inf = float("+inf")
G = 6.67384e-11

def colprint(msg, col):
	print("\x1b[" + str(col) + "m" + msg + "\x1b[m")

def diststr(dist):
	if dist < 1:
		return "%.4fm"  % (dist / 1)
	elif dist < 100:
		return "%.2fm"  % (dist / 1)
	elif dist < 100e3:
		return "%.2fkm" % (dist / 1e3)
	elif dist < 10000e3:
		return "%.1fkm" % (dist / 1e3)
	elif dist < 1000000e3:
		return "%.0fkm" % (dist / 1e3)
	elif dist < 100e9:
		return "%.2fGM" % (dist / 1e9)
	elif dist < 10000e9:
		return "%.1fGM" % (dist / 1e9)
	else:
		return "%.0fGM" % (dist / 1e9)

class Atmosphere:
	"""
	cutoff          The cutoff height (m)
	scaleh		The scale height (where pressure/density decreses by e; m)
	p0		The surface pressure (N/m^2)
	rho0            The surface density (kg/m^3)
	"""
	def __init__(self, cutoff = 0, scaleh = 0, p0 = 0, rho0 = 0):
		self.__dict__.update(locals())

	"""
	h               Height (m)
	returns         Pressure at h (N/m^2)
	"""
	def p(self, h):
		if h >= self.cutoff:
			return 0
		return self.p0 * math.exp(-h / self.scaleh)

	"""
	h		Height (m)
	returns		Air density at h (kg/m^3)
	"""
	def rho(self, h):
		#TODO check whether this is really true
		#in RL, rho ~ 1/T and rho ~ p
		return self.rho0 * self.p(h)/self.p0

	"""
	h               Height (m)
        v               Velocity relative to atmosphere (m/s)
        d               Drag coefficient of the ship (usually 0.2, unitless)
	returns         Acceleration due to drag (m/s^2, positive)
	"""
	def accel(self, h, v, d = 0.2):
		return 0.5 * self.rho(h) * v * v * d

	"""
	h               Height (m)
        d               Drag coefficient of the ship (usually 0.2, unitless)
	returns         Terminal velocity (F_G = F_D, m/s)
	"""
	def vterm(self, h, d = 0.2):
		if h > self.cutoff:
			return inf
		return math.sqrt(self.body.accel(h)/(0.5 * self.rho(h) * d))

class Body:
	"""
	name            Name (will also be used as variable name)
	mass            Mass (kg)
        radius          Radius (m)
	maxelev         Highest elevation over surface (m)
	rotperiod	Siderial rotation period (s)
        atm             Atmosphere (Atmosphere object)
	"""
	def __init__(self, name, mass, radius, maxelev = 0, rotperiod = inf, atm = None):
		if atm == None:
			atm = Atmosphere(cutoff = 0)
		atm.body = self
		self.__dict__.update(locals())
		colprint(name + ": " + diststr(radius) + "m", 33)
		bodies[name] = self
		globals()[name] = self
		print(str(self.loweststableorbit().va()) + "m/s")

	def __repr__(self):
		return self.name

	"""
	returns         Âµ = GM
	"""
	def mu(self):
		return G * self.mass

	"""
	h               height over surface (m)
	returns         acceleration (m/s^2)
	"""
	def accel(self, r):
		return self.mu()/(r * r)

	"""
	returns         radius of the lowest stable orbit (outside atmosphere and above the highest elevation)
	"""
	def minorbitr(self):
		return self.r + max(self.atm.cutoff, self.maxelev)

	"""
	returns         lowest stable orbit object, with an inclination of 0 deg
	"""
	def minorbit(self):
		return self.orbr(self.minorbitr(), self.minorbitr(), 0, name = "lowest" + self.name)

	"""
	creates an orbit object

	ra              height of apogee over center of mass (m)
	rp              height of perigee over center of mass (m)
        incl            inclination against equatorial plane (deg)
	"""
	def orbr(self, ra, rp, incl = 0):
		Orbit(self, ra, rp, incl)

	"""
	creates an orbit object
        
        ha              height of apogee over surface (km)
        hp              height of perigee over surface (km)
	incl            inclination against equatorial plane (deg)
	"""
	def orbh(self, ha, hp, incl = 0):
		rp = 1000 * hp + self.r
		ra = 1000 * ha + self.r
		self.orbr(ra, rp, incl)

	"""
	creates an Orbit object

	a               semi-major axis (m)
        e               eccentricity
	incl		inclination against equatorial plane (deg)
	"""
	def orba(self, a, e, incl = 0):
		rp = (1 - e) * a
		ra = 2 * a - rp
		self.orbr(ra, rp, incl)

	"""
	creates an orbit object

	hp              height of perigee over center of mass (m)
        vinf            velocity at infinity (m/s)
	incl            inclination against equatorial plane (deg)
	"""
	def escorbr(self, rp, vinf = 0, incl = 0):
		a = -self.mu()/(vinf * vinf)
		ra = 2 * a - rp
		self.orbr(ra, rp, incl)

	"""
	creates an orbit object

	hp              height of perigee over surface (km)
        vinf            velocity at infinity
	incl            inclination against equatorial plane (deg)
	"""
	def escorbh(self, hp, vinf = 0, incl = 0):
		rp = 1000 * hp + self.r
		self.escorbr(hp, vinf, incl)

class Orbit(Conic):
	"""
	body            central body
        ha              height of apogee (m)
	hp              height of perigee (m)
	incl            inclination against equatorial plane (deg)
	"""
	def __init__(self, body, ra, rp, incl = 0, name = None):
		if rp < 0:
			raise Exception("periapsis height must be >= 0")
		elif ra == +inf:
			#arbitrary convention: we use -inf for parabolic orbits
			ra = -inf
		elif ra < rp:
			raise Exception("apoapsis height must be >= periapsis height")

		if name == None:
			global orbitidx
			name = "orb" + str(orbitidx)
			orbitidx += 1

		self.__dict__.update(locals())
		
		colprint(name + ": " + str(self), 32)
		orbits[name] = self
		globals()[name] = self

	def __repr__(self):
		if ra < 0:
			#escape trajectory
			return self.body.name + " escape trajectory, " + diststr(self.ra - self.body.r) + "/vinf=" + str(self.v(inf)) + "m/s"
		else:
			#orbit
			return self.body.name + " orbit, " + diststr(self.ra - self.body.r) + "x" + diststr(self.rp - self.body.r)

	"""
	returns         eccentricity
	"""
	def e(self):
		return (1 - self.rp/self.ra) / (1 + self.rp/self.ra)

	"""
	returns         semi-major axis (m)
	"""
	def a(self):
		return (self.ra + self.rp)/2

	"""
	returns         specific energy of the orbit (J/kg)
	"""
	def specenergy(self):
		return -0.5 * self.body.mu() / self.a()

	"""
	returns         orbital period (s)
	"""
	def period(self):
		return 2 * math.pi * sqrt((self.a() ** 3) * self.body.mu())

	"""
	r               height over center of mass (m)
	returns         v (m/s)
	"""
	def v(self, r):
		return math.sqrt(self.body.mu() * (2/r - 1/self.a()))

	"""
	returns         periapsis velocity (m/s)
	"""
	def vp(self):
		return self.v(self.rp)

	"""
	returns         apoapsis velocity (m/s)
	"""
	def va(self):
		return self.v(self.ap)

	"""
	returns         periapsis velocity (m/s)
	"""
	def vp(self):
		return self.v(self.rp)

	"""
	returns         apoapsis velocity or velocity at infinity (m/s)
	"""
	def va(self):
		if self.ra < 0:
			#escape orbit
			return self.v(inf)
		else:
			return self.v(self.ra)

	"""
	rpnew           target periapsis height over center of mass (m)
        returns         apoapsis burn dv
	"""
	def chrp(self, rpnew):
		if self.ha < 0: 
			raise Exception("Can not optimally lower periapsis while on escape trajectory")
		if self.rpnew > self.ra:
			raise Exception("Can not raise periapsis over apoapsis")

		return Orbit(self.body, self.ra, rpnew, self.incl)

	"""
	ranew           target apoapsis height over center of mass (m)
	returns         apoapsis burn dv
	"""
	def chra(self, ranew):
		if ranew > 0 and ranew < self.rp:
			raise Exception("Can not lower apoapsis below periapsis")

		return Orbit(self.body, ranew, self.rp, self.incl)

	"""
	hpnew 	        target periapsis height over surface (km)
	returns         apoapsis burn dv (m/s)
	"""
	def chhp(self, hpnew):OB
		rpnew = 1000 * hpnew + self.body.r
		chrp(self, rpnew)

	"""
	hanew           target apoapsis height over surface (km)
	returns         periapsis burn dv
	"""
	def chha(self, hanew):
		ranew = 1000 * hanew + self.body.r
		chra(self, ranew)

	"""
	returns         apoapsis dv to de-orbit
	"""
	def deorbit(self):
		return self.chrp(self.body.minorbitr())

	"""
        returns         periapsis dv to escape
	"""
	def escape(self):
		return self.chra(inf)

	"""
	returns		periapsis dv to make orbit circular
	"""
	def circ(self):
		return self.chrp(self.ra)

	"""
	r               height over center of orbit (m) at which the inclination change is performed
	inclnew         new inclination
	"""
	def chir(self, r, inclnew):
		if r < self.rp or (self.ra > 0 and r > self.ra):
			raise Exception("Orbit does not reach this height")

		Orbit(self.body, self.ra, self.rp, inclnew)
		#TODO not absolutely sure whether this formula holds for e != 0, but it should
		return 2 * self.v(r) * math.sin(math.rads(self.incl - inclnew))

	"""
	h               height over surface (km) where the inclination change is performed
	inclnew         new inclination
	"""
	def chih(self, h, inclnew):
		r = h * 1000 + self.body.r
		return self.chir(r, inclnew)

	"""
	r               height over center of mass (m)
	returns         angle in orbit (degrees, 0 deg: periapsis)
	"""
	def thetafromr(self, r):
		return math.degrees(acos((self.rp * ( 1 + self.e() ) / r - 1) / self.e()))

	"""
	theta           angle in orbit (degrees, 0 deg: periapsis)
	returns         height over center of mass at that point (m)
	"""
	def rfromtheta(self, theta):
		return self.rp * (1 + self.e()) / (1 + self.e() * math.cos(math.radians(theta)))

	"""
	theta           angle in orbit (degrees, 0 deg: periapsis)
	returns         angle of velocity vector against major axis (degrees, 0 deg: from center of mass to periapsis)
	"""
	def majoraxisvelangle(self, theta):
		return math.degrees(math.atan2(self.e() + math.cos(math.radians(theta)), math.sin(math.radians(theta))))

	"""
	theta           angle in orbit (degrees, 0 deg: periapsis)
	returns         angle of velocity vector against radius vector to center of mass (degrees, 0 deg: towards center of mass)
	"""
	def centervelangle(self, theta):
		return 180 - self.majoraxisvelangle(theta) - theta

	"""
	r               height above center of mass (m)
	returns         (vx, vy) tuple, where negative vy means descent. the sign of vx is irrelevant
	"""
	def vvector(self, r):
		ang = self.centervelangle(self.thetafromr(r))
		absv = self.v(r)
		vx = math.sin(math.radians(ang)) * absv
		vy = math.cos(math.radians(ang)) * absv * -1
		return (vx, vy)

	"""
	r               height above center of mass (m)
	returns         (rx, ry) tuple, where ry is parallel to the major axis
	"""
	def rvector(self, r):
		theta = self.thetafromr(r)
		rx = math.cos(math.radians(theta)) * r
		ry = math.sin(math.radians(theta)) * r
		return (rx, ry)
	
	"""
	numerically simulates aerobreak and creates object for the result orbit
	takes into consideration the rotation of the central body
	"""
	def aerobreak(self):
		if self.hp > self.body.atm.cutoff:
			raise Exception("Orbit not within atmosphere")
		if self.ha < self.body.atm.cutoff:
			raise Exception("Orbit completely within atmosphere")

		#inside the atmosphere, we have a horizontal component and a vertical component
		#in the inertial reference frame (IRF), these depend on hp and ha
		#in the surface reference frame (SRF), due to rotation, inclination also plays a role

		#calculate the atmosphere entry vector in irf
		#absolute value
		ventry_irf_abs = self.v(self.body.atm.cutoff)
		#angle
		#unit vector (inertial reference frame)

"""
deletes all existing orbit variables, (re)sets orbit index counter
"""
def clearorbits():
	for name in orbits:
		orbits.delete(name)
		globals().delete(name)
	global orbitidx
	orbitidx = 0

"""
(re-)reads the body configuration file
"""
def updatebodies():
	exec(open("bodies").read())

#initialize
clearorbits()
updatebodies()
#read pythonstartup script
try:
	import os
	exec(open(os.environ["PYTHONSTARTUP"]).read())
except:
	pass
#launch an interactive session
import code
code.InteractiveConsole(globals()).interact()
